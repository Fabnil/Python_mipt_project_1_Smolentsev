# Описание проекта

Шифрование. Я сделаю консольное приложение,
которое умеет зашифровывать (и дешифровывать) файлы 3 шифрами: Цезаря, Виженера и Вернама.
Также можно будет автоматически взламывать Шифр Цезаря методом частотного анализа.
Коротко об алгоритмах:
- **Шифр Цезаря**: циклический сдвиг алфавита
- **Шифр Виженера**: Цикл цезаря с периодически меняющимся сдвигом (Если кодовое слово - строка S, а текст - строка S1, то i-ый символ S1 перейдёт в S1 + (S[i % S.size()] - 'A'))
- **Шифр Вернама**: побитовый xor всех символов как чисел в ASCII с ключевым символом
- **Взлом шифра Цезаря**:
Буду просто искать самую популярную букву. И также сопосотвлять это с тем, какая буква в большинстве случаев самая популярная (это константная информация, она будет изначально в программе). Ну и получается я знаю сдвиг (в предположении, что в этом тексте популярная буква - та же, что и обычно). А дальше - делаю соответствующий сдвиг обратно.

## Будет 7 функций:

а) Зашифровать / расшифровать шифром Цезаря: надо будет передавать сдвиг и путь к txt файлу
в котором должны будут находиться строго текст на русском или на Английском языке. Язык также нужно передать.
Если в файле будут символы, которые не попадают в интересующий алфавит, то они не будут закодированны (то есть останутся без изменений). 
Шифрование / расшифрование будет происходить in-place, то есть в том же файле,
который передан как аргумент.

б) Зашифровать / расшифровать шифром Виженера: Требования те же (+ язык ключевого слова и язык файла должны совпадать),
что к шифру цезаря, и формат подачи аргументов тот же.
Только вместо Сдвига нужно передать ключевое слово.

в) Зашифровать / расшифровать шифром Вернама. Формат аргументов: ключевой символ (с ним будут xor-иться) и путь к файлу.
Требования к файлу: это должен быть txt файл из символов из таблицы ASCII. 
Ключевой символ как семибитное число будет xor-иться с каждым из символов как при шифровке, так и при дешифровке.

г) Взлом шифра цезаря. Нужно передать путь к файлу и язык (русский / английский). Этот файл будет in-place взломан.
Либо (в случае наличия проблемных символов) - это будет сказано юзеру.

## Архитектура

Будут сделаны такие классы / интерфейсы:

- **(interface) Encryptor** с 2 методами: Encrypt() и Decrypt()
- **(interface) EncryptorByInvolution** - реализует Encryptor с 1 доп. методом: MakeInvolution(), и он будет в Encrypt() и Decrypt()
просто вызывать MakeInvolution()
- **(class) VigenereEncryptor** - реализует Encryptor. Конструируется от пути к файлу, ключевого слова и языка (и будет хранить их как поля).
Будет приватный метод Move(bool invertedMove) - и он будет сдвигать по слову либо вперёд, либо назад (назад <=> invertedMove)
Тогда Encrypt() { Move(False) }, Decrypt() { Move(true) }
- **(class) CaesarEncryptor** - реализует Encryptor. Наследуется от VigenereEncryptor. Можно заметить, что шифр цезаря со сдвигом d это шифр Вижинера с ключём в виде d-ой (считая с нуля) буквы алфавита. Поэтому CaesarEncryptor будет наследоваться от VigenereEncryptor и у него будет конструктор от 3 аргументов: путь, сдвиг и язык, и он будет вызывать конструктор VigenereEncryptor от того же пути, ключа = соотв. букве и того же языка.
- **(class) VermanEncryptor()** - реализует EncryptorByInvolution. Создаётся от символа и пути к файлу (и хранит их как поля), и его MakeInvolution() значит сделать xor= к каждому символу. Если какой-то символ не из ASCII - поведение не определено
- **(class) CaesarHacker** - взломщик шифра цезаря. Он конструируется от 2 параметров: пути к файлу и языка (и хранит их как поля). 
У него будет поле CaesarMover mover и 1 метод: Hack() { 
Он, вычислив сдвиг методом частотного анализа, сделает mover-а CaesarMover с нужным сдвигом и скажет Move() 

## Библиотеки

- **collections.Counter**: Применяется для частотного анализа в взломе Шифра Цезаря. Подсчитывает количество вхождений каждой буквы в тексте.
- **codecs**: Используется для работы с различными системами кодирования текста. Будет использован для реализации шифра Вернама (чтобы узнавать ASCII коды символов).
- **argparse**: для разбора аргументов командной строки.
- **colorama**: для красивого вывода в консоль

В main(): Просим юзера выбрать шифр. Затем просим язык (если это не шифр Вернама). Далее просим путь файлу. Потом просим ключ (т.е. сдвиг в случае шифра цезаря, слово в случае Шифра Вижинера, символ из ASCII в случае с шифром Вернама). После чего файл зашифровывается, то есть его содержимое переходит в зашифрованное содержимое (всё происходит in-place, то есть нового "Зашифрованного" файла не делается).
